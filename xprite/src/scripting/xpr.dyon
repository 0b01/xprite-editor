fn xpr_new(w:f64, h:f64, len:f64) -> any {
    return { w: clone(w), h: clone(h), to_draw: sift _ len {[(0,),(0,)]}, filled: false, i:0 }
}
// random
fn rand(x, y) -> f64 {
    return round(random() * (y-x) + x)
}
fn randint(x) -> f64 {
    return round(random() * (x-1))
}
fn flip_coin() -> bool {
    return randint(2) == 0
}

// fill
fn fill() ~xpr { xpr.filled := true }
fn nofill() ~xpr { xpr.filled := false }

// rectangles
fn rect(x1, y1, x2, y2, col) ~xpr {
    if xpr.filled { _filled_rect(x1, y1, x2, y2, col) }
    else {
        for i [x1, x2) {
            pixel((i,y1), col)
            pixel((i,y2-1), col)
        }
        for j [y1, y2) {
            pixel((x1, j), col)
            pixel((x2-1, j), col)
        }
    }
}
fn _filled_rect(x1, y1, x2, y2, col) {
    for i [x1, x2) {
        for j [y1, y2) {
            pixel((i,j), col)
        }
    }
}
// pixel
fn pixel(pos: vec4, color: vec4) ~mut xpr {
    xpr.to_draw[xpr.i] = clone([pos, color])
    xpr.i += 1
}
